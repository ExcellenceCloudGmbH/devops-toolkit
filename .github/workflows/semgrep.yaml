name: Semgrep reusable scan

on:
  workflow_call:
    inputs:
      isRepoPublic:
        description: "Set to true if the calling repository is public"
        required: true
        type: boolean
        default: false
    secrets:
      SEMGREP_APP_TOKEN:
        required: true
      ARTIFACT_PASSWORD:
        required: false
        description: "Password for encrypting artifacts in public repos"

permissions:
  contents: read
  pull-requests: write

jobs:
  semgrep:
    runs-on: ubuntu-latest
    env:
      SEMGREP_CLOUD_URL: https://semgrep.dev/orgs/excellence-cloud/projects

    steps:
      - name: Checkout PR or branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref_name }}
          fetch-depth: 0

      - name: Install Semgrep CLI and jq
        run: |
          pip install semgrep
          sudo apt-get -qq update
          sudo apt-get -y install jq zip

      - name: Run Semgrep and save JSON
        id: run-semgrep
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        run: |
          # Ensure we start fresh
          rm -f semgrep-results.json
          
          # Run semgrep. Using || true to ensure workflow doesn't crash before reporting
          semgrep ci --json > semgrep-results.json || true
          
          # Validate file creation
          if [ ! -s semgrep-results.json ]; then
            echo "::warning::Semgrep produced an empty file or failed to run."
            echo "count=0" >> "$GITHUB_OUTPUT"
          else
            COUNT=$(jq '.results | length' semgrep-results.json)
            echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          fi

      - name: Comment on PR with Semgrep findings
        if: github.event_name == 'pull_request' && steps.run-semgrep.outputs.count != '0' && !inputs.isRepoPublic
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            try {
              const results = JSON.parse(fs.readFileSync('semgrep-results.json','utf8'));
              if (!results.results?.length || !context.issue?.number) return;

              const uniq = [...new Map(results.results.map(i => [
                `${i.check_id}:${i.path}:${i.start.line}`, i])).values()];

              let body = `**Semgrep found ${uniq.length} unique issue(s):**\n\n`;
              for (const i of uniq) {
                const msg = i.message || i.extra?.message || 'no description';
                body += `- \`${i.path}:${i.start.line}\` **${i.check_id}** â€“ ${msg}\n`;
              }

              const org = "excellence-cloud";
              const repo = encodeURIComponent(`${context.repo.owner}/${context.repo.repo}`);
              const ref = encodeURIComponent(context.ref);
              const scanUrl = `https://semgrep.dev/orgs/${org}/findings?repo=${repo}&ref=${ref}`;
              const supplyChainUrl = `https://semgrep.dev/orgs/${org}/supply-chain/vulnerabilities?repo=${repo}&ref=${ref}`;

              body += `\n---\n[View findings](${scanUrl})\n[Supply chain](${supplyChainUrl})`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            } catch (error) {
              console.error("Error reading results for comment:", error);
            }

      - name: Fail if Semgrep found High/Critical issues
        run: |
          if [ ! -f semgrep-results.json ]; then
            echo "No results file found."
            exit 0
          fi
          high_issues=$(jq '[.results[] | select(.extra.severity == "ERROR" or .extra.severity == "CRITICAL")] | length' semgrep-results.json)
          echo "Semgrep found $high_issues High/Critical issue(s)"
          [ "$high_issues" -eq 0 ] || { echo "Failing due to High/Critical Semgrep findings"; exit 1; }

      - name: Prepare Artifacts
        if: always()
        id: prepare-artifact
        env:
          IS_PUBLIC: ${{ inputs.isRepoPublic }}
          ARTIFACT_PASS: ${{ secrets.ARTIFACT_PASSWORD }}
        run: |
          # Define absolute paths to avoid confusion
          JSON_FILE="${{ github.workspace }}/semgrep-results.json"
          ZIP_FILE="${{ github.workspace }}/semgrep-results.zip"

          # Ensure the source file exists
          if [ ! -f "$JSON_FILE" ]; then
             echo "::warning::Source JSON file not found. Creating empty placeholder to prevent artifact error."
             echo "{}" > "$JSON_FILE"
          fi

          if [ "$IS_PUBLIC" == "true" ]; then
             echo "Public repo detected. Encrypting results..."
             
             # Check if password secret was provided
             if [ -z "$ARTIFACT_PASS" ]; then
               echo "::error::Repo is public but ARTIFACT_PASSWORD secret is missing!"
               exit 1
             fi

             # Zip with password encryption
             # -j: junk paths (do not store directory names)
             # -P: password
             zip -j -P "$ARTIFACT_PASS" "$ZIP_FILE" "$JSON_FILE"
             
             if [ -f "$ZIP_FILE" ]; then
                echo "Encryption successful."
                echo "artifact_path=$ZIP_FILE" >> "$GITHUB_OUTPUT"
             else
                echo "::error::Zip creation failed."
                exit 1
             fi
          else
             echo "Private repo. Keeping raw JSON."
             echo "artifact_path=$JSON_FILE" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload Semgrep results
        if: always() && steps.prepare-artifact.outputs.artifact_path != ''
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: ${{ steps.prepare-artifact.outputs.artifact_path }}
          if-no-files-found: error